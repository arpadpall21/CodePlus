<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Strings </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../Assets/stylesPages.css"> 
    <script src="../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> Strings (ver 4.0.0) </h1>
    <p> Updated ( 2022-03-02 )</p>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Python></a> Strings  
    </p>
<table class="table">
<caption>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method / Property / statement ect... </th>
        <th> Description </th>
    </tr>
    <tr class="0">
        <td> 
            str(<strong>data:any</strong>)
        </td>
        <td> 
            - serializes to string the passed data 
        </td>
    </tr>
    <tr class="0">
        <td colspan="2"> 
            Operators 
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>val:str</strong> <small>not</small> in <strong>str</strong>
        </td>
        <td> 
            - returns <mark>True</mark> if <strong>val</strong> is (<small>not</small>) part of <strong>str</strong>, otherwise returns <mark>False</mark>
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong> + <strong>str</strong>
        </td>
        <td> 
            - joins the two strings together and retuns a new string (does not modify the original strings)
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>[<strong>idx</strong>]
        </td>
        <td> 
            - returns the letter at the specified index 
        </td>
    </tr>
        <tr><td></td><td></td></tr>
    <tr class="0">
        <td> 
            <strong>str</strong>[-<strong>idx</strong>]
        </td>
        <td> 
            - negative indexes are counted from the end (<mark>-1</mark> = last letter / <mark>-2</mark> = second last, etc...)
        </td>
    </tr>
        <tr><td></td><td></td></tr>
    <tr class="0">
        <td> 
            <strong>str</strong>[<i>stIdx(inc)</i>:<i>endIdx(exc)</i>]
        </td>
        <td> 
            - returns the specified range in a new <strong>str</strong> (omitting <i>idx</i> = from the start|to the end)
        </td>
    </tr>
        <tr><td></td><td></td></tr>
    <tr class="0">
        <td> 
            <strong>str</strong>[<i>-endIdx(exc)</i>:<i>-stIdx(inc)</i>]
        </td>
        <td> 
            - negative indexes are counted from the end (<mark>:-1</mark> = second last letter / however <mark>:-0</mark> doesn't work)
        </td>
    </tr>
    <tr class="0">
        <td colspan="2"> 
            Methods 
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.upper()
        </td>
        <td> 
            - converts the string into upper case letters and returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.lower()
        </td>
        <td> 
            - converts the string into lower case letters and returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.casefold()
        </td>
        <td> 
            - converts the string into lower case letters and returns the result in a new string (does not modify the original) <br>
            - does the same as <mark>lower()</mark> but more effective lowering unicode letters (however I didn't see any difference)  
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.capitalize()
        </td>
        <td> 
            - converts the first letter of the string into upper case and returns the result in a new string (does not modify the original) 
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.swapcase()
        </td>
        <td> 
            - swaps letter cases in the string (lower -> upper / upper -> lower)  returns the result in a new string (does not modify the original) 
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.islower()
        </td>
        <td> 
            - return <mark>True</mark> if all letters are lower cases in the string, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.isupper()
        </td>
        <td> 
            - return <mark>True</mark> if all letters are upper cases in the string, <mark>False</mark> otherwise   
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.center(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td> 
            - centers the string by filling white spaces (or <i>char</i>) on both sides on the string and returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.ljust(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td> 
            - left adjust the string by filling white spaces (or <i>char</i>) <u>on the right side (not left side)</u> on the string, returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.rjust(<strong>length:int</strong>, <i>char</i>)
        </td>
        <td> 
            - right adjust the string by filling white spaces (or <i>char</i>) <u>on the left side (not right side)</u> on the string, returns the result in a new string (does not modify the original)
        </td>
    </tr>
    <tr class="0">
        <td> 
            <strong>str</strong>.zfill(<strong>length:int</strong>)
        </td>
        <td> 
            - fills <mark>0</mark> characters on the left side on the string untill the specified length is reached, returns the result in a new string (does not modify the original)
        </td>
    </tr>
    
    
    
    
    
    
    
    
    
    
    <tr class="0">
        <td> 
            <strong>str</strong>
        </td>
        <td> 
            - demo description 
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption> Escape Notations <mark>\</mark>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Notation </th>
        <th> Description </th>
    </tr> 
    <tr class="05.01">
        <td> \<strong>char</strong> </td>
        <td> 
            - character following a backslash is escaped
        </td>
    </tr> 
    <tr class="10.01">
        <td> \<strong>escapeChar</strong> </td>
        <td> 
            - any <span class="openable">escape character<div>
                <p> <mark>\t</mark> - Insert a tab in the text at this point </p>
                <p> <mark>\b</mark> - Insert a backspace in the text at this point </p>
                <p> <mark>\n</mark> - Insert a newline in the text at this point </p>
                <p> <mark>\r</mark> - Insert a carriage return in the text at this point </p>
                <p> <mark>\f</mark> - Insert a formfeed in the text at this point </p>
                <p> <mark>\'</mark> - Insert a single quote character in the text at this point </p>
                <p> <mark>\"</mark> - Insert a double quote character in the text at this point </p>
                <p> <mark>\\</mark> - Insert a backslash character in the text at this point </p>
            </div></span> can be used 
        </td>
    </tr> 
    <tr class="15.01">
        <td> \u<strong>HexHexHexHex</strong> </td>
        <td> 
            - references a unicode UTF-16 character by a <u>4</u> hexadecimal notation (hex => <mark>[0123456789abcdef]</mark>) <u>(can reference only 2 byte long characters)</u>
        </td>
    </tr> 
    <tr class="15.03">
        <td> \x<strong>HexHex</strong> </td>
        <td> 
            - references a latin1 (ISO-8859-1) character by a <u>2</u> hexadecimal notation (hex => <mark>[0123456789abcdef]</mark>)
        </td>
    </tr> 
    <tr class="15.04">
        <td> \<strong>Oct....</strong> </td>
        <td> 
            - references a latin1 (ISO-8859-1) character by a <u>1 to 3</u> octal notation (octal => <mark>[01234567]</mark>) 
        </td>
    </tr> 
</table>
    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - Python encodes strings in UTF-8 (uses 1 to 4 bytes to encode 1 character) </p>
    <p> - strings are iterable, so we can use iterator tools on them (ex: for loop, <mark>in</mark> keyword, etc...) </p>
    <pre class="syntax">
    '<strong>string</strong>'                                                                           // single or double quotes can be used 
    "<strong>string</strong>"
    
    
    '''                                                                                // multiline string (preservers all characters)  
    <strong>string</strong>                                                                               // also used as multiline comment (because string characters are not parsed)   
      <strong>string</strong>
    '''
    </pre>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> escape notation <mark>\</mark> </h2>
    <p> - in strings we can used the <mark>\</mark> escape notation to escape the following character or use any escape characters </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    'this is a \'test\''                                                               // the <mark>'</mark> chacters in the string are escaped (printed as <mark>this is a 'test'</mark>)  
    
// referencing characters from latin-1 table ------------------------------------------
    '\x21'                                                                             // -> '!'        // references the <mark>!</mark> character from the latin-1 table as hexadecimal notation    
    '\41'                                                                              // -> '!'        // references the <mark>!</mark> character from the latin-1 table as octal notation    
    
    
// referencing characters from UTF-16 unicode table -----------------------------------
    '\u0021'                                                                           // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as hexadecimal notation    
    chr(33)                                                                            // -> '!'        // references the <mark>!</mark> character from the UTF-16 unicode table as decimal notation    
    ord('!')                                                                           // -> 33         // returns the passed character's decimal notation from the UTF-16 unicode table   
    
    '\u1fa7'                                                                           // -> 'ᾧ'
    chr(8103)                                                                          // -> 'ᾧ'
    ord('ᾧ')                                                                           // -> 8103
    
    
// UTF-16 2 byte character reference limitation ---------------------------------------
    // -! the 💔 character is referenced as <mark>d83ddc94</mark> hexadecimal or <mark>3627932820</mark> decimal in the unicode table (encoded in 4 bytes), so the below tools cannot reference it because they are limited to reference only 2 byte characters   
    '/ud83ddc94'                                                                       // -> '/ud83ddc94'
    chr(3627932820)                                                                    // -! raises an OverflowError  
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>in</mark> keywords, <mark>+</mark> operator and range slicing <mark>[:]</mark> </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// in operator ------------------------------------------------------------------------
    text = 'Kicsi kutya tarka'
    
    'cs' in text                                                                       // -> True
    'x' not in text                                                                    // -> True
    
// + (operator) -----------------------------------------------------------------------
    size = 'Kicsi '
    animal = 'kutya '
    adjective = 'tarka'
    
    size + animal + adjective                                                          // -> Kicsi kutya tarka    // concateneates strings togehter 
    
    size                                                                               // -> 'Kicsi '             // does not modify originals 
    animal                                                                             // -> 'kutya '
    adjective                                                                          // -> 'tarka'
    
// indexing and range slicing ---------------------------------------------------------
    string = 'this is a test string'
    
    string[0]                                                                          // -> 't'                  // returns the indexed the letter   
    
    string[-1]                                                                         // -> 'g'                  // element order is counted (not indexed) from the back when using negative indexing   
    string[-2]                                                                         // -> 'n'
    
    string[5:7]                                                                        // -> 'is'                 // returns the indexed range 
    string[:4]                                                                         // -> 'this'
    string[10:]                                                                        // -> 'test string'
    
    string[-11:-7]                                                                     // -> 'test'               // indexing from the end 
    string[-6:]                                                                        // -> 'string'
    string[:-7]                                                                        // -> 'this is a test'
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>upper()</mark> / <mark>lower()</mark> / <mark>casefold()</mark> / <mark>capitalize()</mark> / <mark>swapcase()</mark>/ <mark>islower()</mark> / <mark>isupper()</mark> methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
// upper() / lower() / casefold() / capitalize() / swapcase() -------------------------
    text = 'test Ӫ tEsT'
    
    text.upper()                                                                       // -> 'TEST Ӫ TEST'
    text.lower()                                                                       // -> 'test ӫ test'
    text.casefold()                                                                    // -> 'test ӫ test'      // does the same as <mark>lower()</mark>, it's more effective when lowering unicode letters, however I don't see any difference here    
    
    text.capitalize()                                                                  // -> 'Test ӫ test'      // upper case the very first letter only  
    text.swapcase()                                                                    // -> 'TEST ӫ TeSt'      // swap letter cases in the string  
    
    text                                                                               // -> 'test Ӫ tEsT'      // none of the above methods modify the original string   
    
    
// islower() / isupper() --------------------------------------------------------------
    'test'.islower()                                                                   // -> True
    'TEST'.isupper()                                                                   // -> True
    </pre>
</details>
<hr>
<!-------------------------------------------------------------------------------------------->
<h2 class="header"> The <mark>strip()</mark> / <mark>lstrip()</mark> / <mark>rstrip()</mark> / <mark>center()</mark> / <mark>ljust()</mark> / <mark>rjust()</mark> / <mark>zfill()</mark> methods </h2>
<details class="example">
<summary> DEMO </summary>
    <pre>
    text = '  test  '
    
// strip() / lstrip() / rstrip() ------------------------------------------------------
    
    text.strip()                                                                       // -> '  test  '           // removes white spaces from both ends 
    text.lstrip()                                                                      // -> 'test  '             // removes white spaces on the left   
    text.rstrip()                                                                      // -> '  test'             // removes white spaces on the right    
    
    text                                                                               // -> '  test  '           // none of the above methods modify the original string    
    
    
// center() / ljust() / rjust() / zfill() ---------------------------------------------
    text.center(8, '-')                                                                // -> '--test--'           // centers the string by filling the specified character on both sides   
    text.center(7, '-')                                                                // -> '--test-'
    text.center(3, '-')                                                                // -> 'test'               // not modified short length specified    
    
    text.ljust(6, '-')                                                                 // -> 'test--'             // fills the specified character on the rigth untill the specified length reached    
    text.ljust(3, '-')                                                                 // -> 'test'               // not modified short length specified    
    
    text.rjust(6, '-')                                                                 // -> '--test'             // fills the specified character on the left untill the specified length reached    
    text.rjust(3, '-')                                                                 // -> 'test'               // not modified short length specified    
    
    text.zfill(6)                                                                      // -> '00test'             // fills the <mark>0</mark> character on the left untill the specified length reached    
    text.zfill(3)                                                                      // -> 'test'               // not modified short length specified    
    
    text                                                                               // -> '  test  '           // none of the above methods modify the original string     
    </pre>
</details>









<!--
---------------------------------------------------------------------------------------------
WRITE DOWN EVERYTHING NEW
---------------------------------------------------------------------------------------------
    - startswith(<val:str>, [strIdx(inc)], [endIdx(exc)])
                - same as endsWith() -> but other way around 
    - endswith(<val:str>, [strIdx(inc)], [endIdx(exc)])
                - returns a boolean if the string ends with the val (range can be specified )
    - isalnum()
                - return True if all characters in the strings are alphanumeric [a-z0-9] (accent characters included )
                - any other excluded like (space)$@# etc...
    - isalpha()
                - return True if all characters in the strings are alphabet letters [a-z] (accent characters included )
                - any other excluded like (space)$@# etc... numbers 
    - isdecimal()
                - return True if all characters in the strings are decimal characters [0-9] 
                - any other excluded like (space)$@# etc... numbers 
    - isdigit()
                - same as isdecimal() but for all digist ex (² = is a digit too)
    - isnumeric()
                - same as isdecimal() but for all digits ex (² and ¾ = is a digit too)
    - isidentifier()
                - returns True if the string is a valid identifier (= valid variable [a-z0-9_])
    - isprintable()
                - returns True if all characters are printable 
                - \t \r -> characters are not printable 
    - istitle()
                - returns True if the string starts with an upper case letter (an the rest is all lowercased)
    - isspace()
                - returns True if all characters are white spaces 
    
    
    
    - count(<match:str>)
                - returns how many times match is found in the string 
    - find(<val:str>, [stIdx(inc)], [endIdx(exc)])
                - returns the index where the first ocurence of <val> is found (-1 if not found)
                - optional search range can be specified 
    - index(<val:str>, [stIdx(inc)], [endIdx(exc)])
                - returns the index where the first ocurence of <val> is found (raises an exception if not found)
                - optional search range can be specified 
    - rfind(<val>, [stIdx(inc)], [endIdx(exc)])
                - this is 'find()' but searches from end to start 
    - rindex()
                - same as index() -> but end to start 
    
    
    
    
    - split(char) 
                - returns a list of the sliced parts 
    - join(<iteralbe>)
                - appends itmes in the tuple at the end of the string 
                - does not modifies the original string 
    - partition(<match:str>)
                - returns a tuple with 3 parts 1 -> before match 2 -> match 3 -> after match 
                - first occurence 
                - does not modify the original string
    - rpartition()
                - same as partition() but end to start 
    - rsplit()
                - same as split but end to start 
    - splitlines(keep line break characters in the returned string = boolean)
                - split string at line breaks, and returns the result in a list (for \n and \r)
    
    
    
    
    - format(<varVAl>, ...)
                - parses the passed arguments into strings and puts them in {}
                - does not mofiy the original string
                - expects as many arguments as {} are in the string (or we can index passed values in {}) (we also can pass key=val pairs) (index and key=val can be combined)
                - does not modify the original string (only returns the result)
                - 'test {2} test {1} test {3} test {0}'.format('one', 'two', 'three', 'four')
    - format_map(<dict>)
                - same as format but takes a dictionary 
    - expandtabs(<tabSize:nr>)
                - sets how many white spaces the tab characters (\t) uses (modifies the original string)
    - translate(<dict>)
                - replaces characters in the string identified by ascii codes  
                - does not modify the original string 
    - maketrans()
                - these tow methos are for some shitty replace mechanism 
    - replace(<targets:str>, <replace:str>)
                - replaces all matches and return the result 
                - does not modify the original string  
    
    
    
    
    
    - encode(encoding=<encode>, error=<err>)
                - encodes the string (ascii, latin1, utf-8, utf-16, utf-32)
                - returns the resut as bytes object 
    
    
    
    
    
    
    









?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????

-->




<!--

- string
    - uses utf-8 to encoding and store characters
    - explain this down on the encoding table -|
    - single or double quotes are ok, 
    - multiline string ok with single or double quotes
    
    
    
    
    
    
    - strings are iterable (as unicode characters)
    - the 'in' or 'not in' operator can find parts of a string (returns a boolean)
    - uses the same range slice as tuple and lists do 
        - omiting index mean till the start|end
        - negative indexing can be used (starts from the end => indexes work the same way here to (start idx included end index excluded))
    - the '+' operator concatenates strings togehter (does not modify originals)
    - the \ is the escape character 
    - \uHexHexHexHex    <- references UTF-16 unicode 
    
    
    - chr(dec)
            - global function 
            - references UTF-16 encoded charactes by decimal notation 
    - ord(char:str)
            - returns the unicode decimal notation of the passed characters 
    
    
    - \xHexHex
            - references a latin 1 characters (hex notation)
    - \OctOct
            - references a latin-1 character (octal notation)
    
    - \.  and \x..   and \u.... <= unicode is utf-16
                - octal and hex (does this references utf-8 characters)
    - escape characgter is \<escapedCharacter> (\n = new line, \t = tab, etc..., \o = octal, \x =hex)
        - test \0 \x (octal adn decimal escaping)
            - apparently these guys can only reference ASCII characters -> TEST -> yep it seems to be only 2/4 characters are allowed 



    - .upper() 
                - upper case all leters 
                - does not modify original
    - .lower() 
                - lower case all letters 
                - does not modify original
    - casefold()
                - converts all characters into lowercase (does the same as lower() but more effective lowering unicode characters, in my test doesn't seems to have any difference, maybe in some edge cases)
                - does not modify the original 
                - does not modify original
    - capitalize()
                - converts the first leter of the string into a capital letter and returns the result 
                - does not modify the original 
    - swapcase()
                - swap letter casses in the string 
                - does not modify the original 
    - islower()
                - returns True if all characters are lowercased 
    - isupper()
                - returns True if all characters are upper case letters 



    - strip() 
                - removes white space on both end 
                - does not modify the original
    - lstrip([match:str])
                - removes all matching char on the left side (white space default)
                - does not modify the original
    - rstrip([match:str])
                - removes all matching char on the left side (white space default)
                - does not modify the original
    - center(<len:nr>, [char:str])
                - centers the string by adding spaces (or char) arround the string 
                - does not modify the original 
    - ljust(<len:nr>, [char:str]) 
                - left addjust 
                - this basically adds [char] on the right side 
                - does not modify the original 
    - rjust(<len:nr>, [char:str])
                - right addjust 
                - this basically adds [char] on the right side 
                - does not modify the original 
    - zfill(len:nr) 
                - adds '0' chars a the start to fill the lenght 
                - does not modify the original 


-->
    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr><hr><hr><hr><hr>
    
    
<h2 class="headerExtra"><u> Title 1 </u></h2>
<h2 class="header"> Title 1.1 </h2>
<h3 class="header"> Title 1.1.1 </h3>
<h4 class="header"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>syntax or command (or some tchnical stuff)</mark> bla bla bla </p>
    <p> - stuff to learn <mark class="mark">highlights like file names and other things</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
        <p> - red background block means not learned or not tested information! </p>
        <p> - </p>
    </div>
    
    <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>
    
<details class="example">
<summary> DEMO </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
</details>
    
    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
        <details>
        <summary> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
        </details>
</details>
<!---------------------------------------------------------------------------------------------------------------------------------->    
<hr>
    
<h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>
    
    
    <br><br>
</body>
</html>
