<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> Object </title> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>  
    <link rel="stylesheet" href="../../Assets/styles.css"> 
    <script src="../../Assets/script.js"></script>
</head>
<body>
<h1> Object (ver 4.0.0) </h1>
    <p class="sitenav"> <a href="../../index.html">MySite></a>
        <a href="../index.html">Python></a> Objects 
    </p>
    <div class="content">
        <h2><a class="ver-live" href="Classes and Prototypes/index.html"> Classes and Prototypes (4.0.0) </a></h2>
        <h2 style="background-color:green;"><a class="ver-live" href="Objects/index.html"> Object (4.0.0) </a></h2>
    </div>
<hr>
    <div class="content">
        <h2 style="background-color:red;"><a class="ver-live" href="Iterator Object/index.html"> Iterator Object (4.0.0) </a></h2>
    </div>
</body>
</html>


<!--
---------------------------------------------------------------------------------------------
WRITE DOWN EVERYTHING NEW
---------------------------------------------------------------------------------------------
- iterators and generators 
    - well this is cool and all but it's better to use generator functions for this goal 
    - iterators implement the __iter__() and __next__()
    - the iter(<iterable>) returns an iterator then we can use the next() on the iterator object to get the next value 
    - the for loop actually creates an iterator and execute the next() method for each cycle
    - calling the next() on the iteration is over will rise an exception
    - this essentially creates a generator 
    - StopIteration statement stops the iteration 
    - generator function 
        - function having the yield keyword automatically becomes a generator function 
        - the generator function returns a generator ojbect on which we can call the iter() or loop through it


    <obj>.__iter__
                - object having it is iterable (ex: hasattr(<obj>, __iter__))
    i for i in <iterable>
                - creates a generator object from <iterable>





?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
    
-->



<!--
    - in python an object is not a dictionary!!! (obj.key VS dict["key"])
    - python is OOP (but not prototype-based language)
    - the 'self' = parameter does not have to be called self
    - parent|child class 
    - object properties are caled attributes here 


    - dict(obj)    - to print as dictionary
    - passing self as 1st argument won't count in the final object as 1st argument 
    - class MyClass(ParentClass)    -> extend 
    - super() 
    - allows to have multiple base classes 
    - the first argument represents the object that will be created (self) 
- Classes/Objects
    - we also have docstring here (like functions do) (printalbel with __doc__ - like functions do)

    - both public property and function are inherited by instances (not owned) 
    - Class() - creates a new object instance 
    - the __init__(self) - like constructor 
    - we call 'data attribute' and 'method' 
    - when the called a method or attribute is not found in the object instance then it is searched in its class 
    - static methods are specified with @classmethod or @staticmethod 
        - transform the method into classmethod (first argument will be this class) 
        - classmethod can be called on the instance as well (but the received 1st argument is the class) 
    - static attributes are accessible directly (apparently) -> <Class>.prop (so static attibutes are not that static => whell they are accessible by instances but instances cannot modify it, => yes they can when immutabl, => so instance will create their own if the static is immutable but modify the classes static attribute if it it's immutable)
    - calling <instance>.method() is the same as calling <Class>.method(<instance>) 
    - multiple inheritance allowed (in this calse the lokup is from left-to-right) - depth-first search (searches fully the first class )
    - because there are diamond paths (for example the object class can be accessed on multiple routes the dynamic class order algorithm ordert the class access path that the object class is accessed only once but preservers the depth-first search left-to right way to do shit)
    - references the upper class (perform a class lookup to find the searched class attribute or class method) (gets the first found)
    - no private variable but the convention is prefixing with __ (double underscore) (data attribute, or method)
    
    - super() syntax from version 3.0
    - super(<thisClass>, <self>) -> 2.7
    - the super() always tries to find its own classe's super 
    
    
    - <Class>.__mro__ 
                  - (Method Resolution Order) - prints the class resolution path 
    - <Class>.__bases__ 
                  - returns the direct parent classes of this class  
    - isinstance(obj, class) 
                  - True if instance of class (class is on the prototype chain) 
    - issubclass(parentClass, class) 
                  - True if class is somewhere subclass of parntClass
    - type(val) 
                  - returns the <val>'s direct class 
    - <val>.__class__ 
    

    
-->
