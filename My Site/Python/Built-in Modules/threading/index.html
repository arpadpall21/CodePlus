<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> threading </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css">
    <script src="../../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> threading </h1>
    <p> Updated ( 2022-07-12 )</p>
    <p class="sitenav"> <a href="../../../index.html">MySite></a>
        <a href="../../index.html">Python></a>
        <a href="../index.html">Built-in modules></a> threading
    </p>
<table class="table">
<caption>
    threading
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
    <tr class="05.01">
        <td> 
            <em>treading</em>.Thread(<small class="openable">group=None<div>
                <p> - not yet implemented argument (v3.10) </p>
            </div></small>, <small class="openable">target=<i>fn</i><div>
                <p> - function executed by the thread (Default: <mark>None</mark>) </p>
            </div></small>, <small class="openable">args=<i>iterable</i><div>
                <p> - arguments passed to the target function (iterable format) </p>
            </div></small>, <small class="openable">kwargs=<i>dict</i><div>
                <p> - arguments passed to the target function (dictionary format) </p>
            </div></small>, <small class="openable">daemon=<i>bol</i><div>
                <p> - thread runs as daemon (separate background process) </p>
                <p> - the main thread won't wait for this thread end because this thread will run in the background </p>
            </div></small>)
        </td>
        <td> 
            - creates and returns a <strong>thread</strong> object which represents activity that is run in a separate thread of control
        </td>
    </tr>
    <tr class="10.01">
        <td>
            <strong>thread</strong>.join()
        </td>
        <td>
            - waits untill the thread terminates (block further execution)
        </td>
    </tr>
    <tr class="10.02">
        <td>
            <strong>thread</strong>.start()
        </td>
        <td>
            - stats the thread (this call won't block further execution)
        </td>
    </tr>
    <tr class="15.01">
        <td>
            <em>threading</em>.active_count()
        </td>
        <td>
            - returns the number of threads currently running (main thread including)
        </td>
    </tr>
    <tr class="15.02">
        <td>
            <em>threading</em>.active_enumerate()
        </td>
        <td>
            - returns all running <strong>thread</strong> objects in a list (main thread including)
        </td>
    </tr>
    <tr class="20.01">
        <td>
            <em>threading</em>.current_thread()
        </td>
        <td>
            -  returns the current <strong>thread</strong> object (where it is called)
        </td>
    </tr>
    <tr class="20.02">
        <td>
            <em>threading</em>.main_thread()
        </td>
        <td>
            - returns the main <strong>thread</strong> object
        </td>
    </tr>
    <tr class="25.01">
        <td>
            <em>threading</em>.get_ident()
        </td>
        <td>
            - return the thread identifier (nonzero integer) 
            <span id="browserSupport" title="updated : 2022-07-18">
                <span><i class="fab fa-python"></i> 3.3 </span>
            </span>
        </td>
    </tr>
    <tr class="25.02">
        <td>
            <em>threading</em>.get_native_id()
        </td>
        <td>
            - return the thread identifier (nonzero integer) <u>thread id assigned by the kernel</u>
            <span id="browserSupport" title="updated : 2022-07-18">
                <span><i class="fab fa-python"></i> 3.8 </span>
            </span>
        </td>
    </tr>
    <tr class="30.01">
        <td colspan="2"> - </td>
    </tr>
    <tr class="30.02">
        <td>
            <em>threading</em>.Timer(<strong>delay:float</strong>, <strong>fn</strong>, <small class="openable">args=<i>iterable</i><div>
                <p> - arguments passed to the thread function (iterable format)</p>
            </div></small>, <small class="openable">kwargs=<i>dict</i><div>
                <p> - arguments passed to the thread function (dictionary format) </p>
            </div></small>)
        </td>
        <td>
            - returns a <strong>thread</strong> object which executes the passed function in a thread after the specified delay (once the <mark>start()</mark> is called on it)
        </td>
    </tr>
    <tr class="30.03">
        <td>
            <strong>thread</strong>.cancel()
        </td>
        <td>
            - stops the timer and cancesl the thread execution
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption>
    <mark>Lock</mark> & <mark>RLock</mark>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
    <tr class="00.00">
        <td> 
            <em>threading</em>.Lock()
        </td>
        <td> 
            - creates and returns a <strong>lock</strong> object which can be <span class="openable">locked only once<div>
                <p> - once this lock is acquired further calls to <mark>acquire()</mark> are blocked untill the lock is released </p>
            </div></span> <br>
            - supports the context management protocol (acqured when entering | released when exiting the context)
        </td>
    </tr>
    <tr class="00.00">
        <td> 
            <em>threading</em>.RLock()
        </td>
        <td> 
            <!-- - creates and returns a <strong>lock</strong> object which can be locked only once <br>
            - supports the context management protocol (acqured when entering | released when exiting the context) -->
        </td>
    </tr>
    <tr class="00.00">
        <td> 
            <strong>lock</strong>.acquire(<small class="openable">blocking=<i>bol</i><div>
                <p> - blocks furter execution when the <strong>lock</strong> is already acquired (Default: <mark>True</mark>)
            </div></small>)
        </td>
        <td> 
            - acquires (closes) the lock 
        </td>
    </tr>
















</table>
    <br>



    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://docs.python.org/3/library/threading.html" target="_blank">Threading (docs.python.org)</a></p>
    <p><a href="https://realpython.com/intro-to-python-threading/" target="_blank">Threading (realpython.com)</a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - the <mark class="mark">threading</mark> module allows parallel programming in Python (we can run multiple tasks concurrently) </p>
    <p> - the idea behind threading is to run multiple tasks <u>at the same time</u> what need to wait for some kind of external even (like DB query) so they don't block each other (ex: running 3 tasks in parallel  taking 2 seconds each will take a little over 2 seconds to complish because they don't block each other (sequencially this would take 6 seconds)) </p>
    <p> - threading does not help you with performance, use <mark class="mark">multiprocessing</mark> for that </p>
    <p> - by default the main thread waits for all threads (tasks) to end, but tasks can run as daemons (background processes), this way they are independed from the main thread, but also the main thread won't wait from daemon tasks to finish </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    import threading
    import time
    
    def th(name, delay):                                                      # will run in a separate thread
        print(f'{name} started')
        time.sleep(delay)                                                     # simulates some non cpu intensive task
        print(f'{name} end!')
    
    a = threading.Thread(target=th, args=["Thread-1", 3])
    b = threading.Thread(target=th, args=["Thread-2", 2])
    c = threading.Thread(target=th, args=["Thread-3", 1], daemon=True)        # thread runs as daemon 
    
    a.start()                                                                 # starting threads 
    b.start()
    c.start()
    
    c.join()                                                                  # block further execution untill thread 'c' ends
    </pre>
    <p> - <mark>Time()</mark> </p>
    <pre>
    import threading
    import time
    
    def thread(name):
        print( f'thread {name} started')
        time.sleep(3)                                                         # simulates some non cpu intensive task
        print( f'thread {name} end')
    
    th1 = threading.Timer(2.5, thread, args=[1])                              # delayed thread created
    th2 = threading.Timer(1.2, thread, args=[2])
    
    th1.start()                                                               # starting threads execution
    th2.start()
    </pre>
</details>
<h2 class="header"> Lock, Semaphore, Barrier </h2>
    <p> - these are tools to handle race conditions </p>
    <p> - a Lock can be locked or unlocked, the idea is that several threads use the same lock but only one of them unlock it, other threads wait until the lock unlocks again (ex: connecting to DB with this lock approach makes shure that there's only one query at a time) </p>
    
    
<details class="example" open>
<summary> DEMO </summary>
    <p> - <mark>Lock</mark> </p>
    <pre>
    import threading 
    import time
    
    lock = threading.Lock()
    
    def th(name, lock):
        print( f"{name} tread started")
        time.sleep(3)
    
        with lock:                                        # lock acqured when entering context / lock released when exiting context
            pass
        print( f"{name} tread end")
    
    threading.Thread(target=th, args=[1, lock]).start()
    threading.Thread(target=th, args=[2, lock]).start()   # thread 2 will wait untill the lock is released
    </pre>
    <pre>
    import threading
    
    lock = threading.Lock()
    
    lock.acquire()
    
    print( lock.locked() )                                // -> True
    lock.acquire()                                        # program will hang because the lock is closed (this is called deadlock)
    </pre>
    
    
</details>

    
    
<!--
    -
    -





-->









<!--
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------
stage 1: high level overview 
    - read through 
    - create notes 
    - deciede what exactly will you document down 
    
stage 2:  low level overview
    - deeper understanding of all what you've taken down in stage 1
    
stage 3 : 
    - organize and document down everything 
---------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------

- parallel programming 
- threads run parallel but not speed up program, its useful when threads needs to wait for some outside events (they don't block each other), but for cpu intensive task we do not gain (this is because of CPython GIL implementation )
- for cpu intensive task use multiprocessing instead 
- the main thread will waif for all threads to finish before exiting, however thread daemons are independent from the main thread 

- Timer()       - starts executing the function in a thread after the specified time 


<em>threading</em>.Lock()
    - creates and returns a <strong>lock</strong> object (can be unlocked only once)




- Lock is a way to avoid race conditions, the idea is that the lock is owned by all running threads but can be unlocked by only one of them so other wait for the lock
- the RLock can be unlocked by multiple threads (to avoid dead lock problem) but still garantees concurency 






- Semaphore can control how many locks are released (supports context protocol)
- Semaphore has no upper limit (each release adds more locks) VS BoundedSemaphore has upper limit which cannot be exceeded by release 

- Barrier()     - number of patients must wait (at the barrier) to reach a point before all released at once 
                - 


- 
     











    </span>










?????????????????????????????????????????????????????????????????????????????????????????????
WRITE DOWN WHAT YOU DON'T UNDERSTAD OR MUST BE TESTED AS QUESTIONS HERE
?????????????????????????????????????????????????????????????????????????????????????????????
  - daemon thread ???
-->


    <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    <hr><hr><hr><hr><hr>
    
    
<h2 class="headerExtra"><u> Title 1 </u></h2>
<h2 class="header"> Title 1.1 </h2>
<h3 class="header"> Title 1.1.1 </h3>
<h4 class="header"> Title 1.1.1.1 </h4>
    <p> - stuff to learn <mark>syntax or command (or some tchnical stuff)</mark> bla bla bla </p>
    <p> - stuff to learn <mark class="mark">highlights like file names and other things</mark> bla bla bla </p>
    <p style="text-decoration:underline;"> - important information is underlined </p>
    <p style="color:yellow;"> - very important information is written with yellow colors </p>
    <p style="background-color:yellow;"> - highly important information has yellow background color </p>
    <div style="background-color:red;">
        <p> - red background block means not learned or not tested information! </p>
        <p> - </p>
    </div>
    
    <pre class="syntax">
SYNTAX :    main syntax
            <em>literally used </em>
            <small>literally used optional </small>
            <prot style="color:#049500;">prototype chain</prot>
            <strong>required value </strong>
            <i>optional value </i>
                - some descriptions will come here (like arguments)
                - ??? (3 question marks) in syntax means not tested or not learned yet
                
            <span class="openable"> this is an openable element<div>
                <p> - openable elements listed here in paragraphs </p>
                <p> - </p>
            </div></span>
    </pre>
    
<details class="example">
<summary> DEMO </summary>
    <pre>
    examples of the current lessons 
    
// -----------------------------------------

// -----------------------------------------
    </pre>
</details>
    
    <pre class="cmd">
    command line demo 
    </pre>
    <pre class="formula">
    formula code (like conversion meter...)
    </pre>
<details class="example">
<summary> Example : </summary>
<h4 style="color:darkblue;"><u> example title </u></h4>
    <p> - live tests will come here </p>
        <details>
        <summary> CODE : </summary>
        <pre>
    copy of the exaple code 
        </pre>
        </details>
</details>
<!---------------------------------------------------------------------------------------------------------------------------------->    
<hr>
    
<h2 class="test" style=""><a href="TEST/index.html"> TEST > </a></h2>
    
    
    <br><br>
</body>
</html>
