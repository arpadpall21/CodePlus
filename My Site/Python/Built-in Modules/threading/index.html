<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title> threading </title> 
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous"> 
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <link rel="stylesheet" href="../../../Assets/stylesPages.css">
    <script src="../../../Assets/scriptPages.js"></script>
</head>
<body>
<h1> threading </h1>
    <p> Updated ( 2022-07-12 )</p>
    <p class="sitenav"> <a href="../../../index.html">MySite></a>
        <a href="../../index.html">Python></a>
        <a href="../index.html">Built-in modules></a> threading
    </p>
<table class="table">
<caption>
    threading
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
    <tr class="05.01">
        <td> 
            <em>treading</em>.Thread(<small class="openable">group=None<div>
                <p> - not yet implemented argument (v3.10) </p>
            </div></small>, <small class="openable">target=<i>fn</i><div>
                <p> - function executed by the thread (Default: <mark>None</mark>) </p>
            </div></small>, <small class="openable">args=<i>iterable</i><div>
                <p> - arguments passed to the target function (iterable format) </p>
            </div></small>, <small class="openable">kwargs=<i>dict</i><div>
                <p> - arguments passed to the target function (dictionary format) </p>
            </div></small>, <small class="openable">daemon=<i>bol</i><div>
                <p> - thread runs as daemon (separate background process) </p>
                <p> - the main thread won't wait for this thread end because this thread will run in the background </p>
            </div></small>)
        </td>
        <td> 
            - creates and returns a <strong>thread</strong> object which represents activity that is run in a separate thread of control
        </td>
    </tr>
    <tr class="10.01">
        <td>
            <strong>thread</strong>.join()
        </td>
        <td>
            - waits untill the thread terminates (block further execution)
        </td>
    </tr>
    <tr class="10.02">
        <td>
            <strong>thread</strong>.start()
        </td>
        <td>
            - stats the thread (this call won't block further execution)
        </td>
    </tr>
    <tr class="15.01">
        <td>
            <em>threading</em>.active_count()
        </td>
        <td>
            - returns the number of threads currently running (main thread including)
        </td>
    </tr>
    <tr class="15.02">
        <td>
            <em>threading</em>.active_enumerate()
        </td>
        <td>
            - returns all running <strong>thread</strong> objects in a list (main thread including)
        </td>
    </tr>
    <tr class="20.01">
        <td>
            <em>threading</em>.current_thread()
        </td>
        <td>
            -  returns the current <strong>thread</strong> object (where it is called)
        </td>
    </tr>
    <tr class="20.02">
        <td>
            <em>threading</em>.main_thread()
        </td>
        <td>
            - returns the main <strong>thread</strong> object
        </td>
    </tr>
    <tr class="25.01">
        <td>
            <em>threading</em>.get_ident()
        </td>
        <td>
            - return the thread identifier (nonzero integer) 
            <span id="browserSupport" title="updated : 2022-07-18">
                <span><i class="fab fa-python"></i> 3.3 </span>
            </span>
        </td>
    </tr>
    <tr class="25.02">
        <td>
            <em>threading</em>.get_native_id()
        </td>
        <td>
            - return the thread identifier (nonzero integer) <u>thread id assigned by the kernel</u>
            <span id="browserSupport" title="updated : 2022-07-18">
                <span><i class="fab fa-python"></i> 3.8 </span>
            </span>
        </td>
    </tr>
    <tr class="30.01">
        <td colspan="2"> - </td>
    </tr>
    <tr class="30.02">
        <td>
            <em>threading</em>.Timer(<strong>delay:float</strong>, <strong>fn</strong>, <small class="openable">args=<i>iterable</i><div>
                <p> - arguments passed to the thread function (iterable format)</p>
            </div></small>, <small class="openable">kwargs=<i>dict</i><div>
                <p> - arguments passed to the thread function (dictionary format) </p>
            </div></small>)
        </td>
        <td>
            - returns a <strong>thread</strong> object which executes the passed function in a thread after the specified delay (once the <mark>start()</mark> is called on it)
        </td>
    </tr>
    <tr class="30.03">
        <td>
            <strong>thread</strong>.cancel()
        </td>
        <td>
            - stops the timer and cancesl the thread execution
        </td>
    </tr>
</table>
    <br>
<table class="table">
<caption>
    <mark>Lock</mark> & <mark>RLock</mark>
    <span class="changeListOrder">[Ordered: <span>Alphabetically</span>]</span>
</caption>
    <tr>
        <th style="width:30%;"> Method </th>
        <th> Description </th>
    </tr>
    <tr class="05.01">
        <td colspan="2"> <mark>Lock</mark> simple lock </td>
    </tr>
    <tr class="05.02">
        <td> 
            <em>threading</em>.Lock()
        </td>
        <td> 
            - creates and returns a <strong>simpleLock</strong> <br>
            - can be locked|unlocked only once by any threads <br>
            - supports the context management protocol (<strong>simpleLock</strong> <mark>acquire()</mark> when entering | <mark>release()</mark> when exiting the context)
        </td>
    </tr>
    <tr class="10.01">
        <td> 
            <strong>simpleLock</strong>.acquire(<small class="openable">blocking=<i>bol</i><div>
                <p> - blocks furter execution when the <strong>lock</strong> is already acquired (Default: <mark>True</mark>)
            </div></small>, <small class="openable">timeout=<i>float</i><div>
                <p> - after this delay the lock is unlocked (Default: <mark>-1</mark> = no delay) </p>
            </div></small>)
        </td>
        <td> 
            - acquires (locks) the lock <br>
            - if the <strong>simpleLock</strong> is alread locked blocs further executions untill the lock is released 
        </td>
    </tr>
    <tr class="10.02">
        <td> 
            <strong>simpleLock</strong>.release()
        </td>
        <td> 
            - releases (unlocks) the lock
        </td>
    </tr>
    <tr class="15.01">
        <td> 
            <strong>simpleLock</strong>.locked()
        </td>
        <td> 
            - returns <mark>True</mark> if the <strong>simpleLock</strong> is locked, otherwise returns <mark>False</mark>
        </td>
    </tr>
    <tr class="20.01">
        <td colspan="2"> <mark>RLock</mark> reentral lock </td>
    </tr>
    <tr class="20.02">
        <td> 
            <em>threading</em>.RLock()
        </td>
        <td>
            - creates and returns a <strong>reentralLock</strong> <br>
            - thread awaire, the thread that locks it only that thread can unlock it again <br>
            - can be unlocked multiple times within the same thread (must be locked as many times as it was unlocked in order to release the lock) <br>
            - supports the context management protocol (<strong>simpleLock</strong> <mark>acquire()</mark> when entering | <mark>release()</mark> when exiting the context) <br>
            - <u> automatically released when the thread is killed </u>
        </td>
    </tr>
    <tr class="25.01">
        <td> 
            <strong>reentralLock</strong>.acquire(<small class="openable">blocking=<i>bol</i><div>
                <p> - blocks furter execution when the <strong>lock</strong> is already acquired (Default: <mark>True</mark>)
            </div></small>, <small class="openable">timeout=<i>float</i><div>
                <p> - after this delay the lock is unlocked (Default: <mark>-1</mark> = no delay) </p>
            </div></small>)
        </td>
        <td> 
            - acquires (locks) the lock in this thead <br>
            - within the same thread unlock the lock several times <br>
            - if the <strong>reentralLock</strong> is locked by another thread block further execution untill the lock is released by the thred that locked it
        </td>
    </tr>
    <tr class="25.02">
        <td> 
            <strong>reentralLock</strong>.release()
        </td>
        <td> 
            - releases (unlocks) the lock <br>
            - only the thread that locked the <strong>reentralLock</strong> can unlock it again
        </td>
    </tr>
</table>
    <br>
    <details class="example" id="notes">
    <summary> Notes :</summary>
        <!-- <p> - paragraph removes the 'empty' message from the detail TAG -->
    </details>
<h2 style="color:green;"><u> Useful Links : </u></h2>
    <p><a href="https://docs.python.org/3/library/threading.html" target="_blank">Threading (docs.python.org)</a></p>
    <p><a href="https://realpython.com/intro-to-python-threading/" target="_blank">Threading (realpython.com)</a></p>
<h2 style="color:green;"><u> Remember This : </u></h2>
    
<h2 style="color:green;"><u> Description and Demonstration : </u></h2>
    <p> - the <mark class="mark">threading</mark> module allows parallel programming in Python (we can run multiple tasks concurrently) </p>
    <p> - the idea behind threading is to run multiple tasks <u>at the same time</u> what need to wait for some kind of external even (like DB query) so they don't block each other (ex: running 3 tasks in parallel  taking 2 seconds each will take a little over 2 seconds to complish because they don't block each other (sequencially this would take 6 seconds)) </p>
    <p> - threading does not help you with performance, use <mark class="mark">multiprocessing</mark> for that </p>
    <p> - by default the main thread waits for all threads (tasks) to end, but tasks can run as daemons (background processes), this way they are independed from the main thread, but also the main thread won't wait from daemon tasks to finish </p>
<details class="example">
<summary> DEMO </summary>
    <pre>
    import threading
    import time
    
    def th(name, delay):                                                      # will run in a separate thread
        print(f'{name} started')
        time.sleep(delay)                                                     # simulates some non cpu intensive task
        print(f'{name} end!')
    
    a = threading.Thread(target=th, args=["Thread-1", 3])
    b = threading.Thread(target=th, args=["Thread-2", 2])
    c = threading.Thread(target=th, args=["Thread-3", 1], daemon=True)        # thread runs as daemon 
    
    a.start()                                                                 # starting threads 
    b.start()
    c.start()
    
    c.join()                                                                  # block further execution untill thread 'c' ends
    </pre>
    <p> - <mark>Time()</mark> </p>
    <pre>
    import threading
    import time
    
    def thread(name):
        print( f'thread {name} started')
        time.sleep(3)                                                         # simulates some non cpu intensive task
        print( f'thread {name} end')
    
    th1 = threading.Timer(2.5, thread, args=[1])                              # delayed thread created
    th2 = threading.Timer(1.2, thread, args=[2])
    
    th1.start()                                                               # starting threads execution
    th2.start()
    </pre>
</details>
<hr>
<!--------------------------------------------------------------------------------->
<h2 class="header"> Race Condition Control </h2>
    <p> - a simple <mark>Lock</mark> can be locked or unlocked, the idea is that several threads use the same lock but only one of them unlock it, other threads wait until the lock unlocks again (ex: connecting to DB with this lock approach makes shure that there's only one query at a time) </p>
    <p> - the reentral lock <mark>RLock</mark> has 2 advantages over the simple lock: </p>
    <p style="text-indent:30px;"> - thread aware, meaning knows which thread acquired (locked) it and <u>only the acquiring thread can unlock it again</u> </p>
    <p style="text-indent:30px;"> - within the same thread can be acquired (unlocked) several times (must be released (locked) as many times as it was arquired (locked) to release the lock) </p>
<details class="example">
<summary> DEMO </summary>
    <p> - <mark>Lock</mark> </p>
    <pre>
    import threading 
    import time
    
    lock = threading.Lock()
    
    def th(name, lock):
        print( f"{name} tread started")
        time.sleep(3)
    
        with lock:                                        # lock acqured when entering context / lock released when exiting context
            pass
        print( f"{name} tread end")
    
    threading.Thread(target=th, args=[1, lock]).start()
    threading.Thread(target=th, args=[2, lock]).start()   # thread 2 will wait untill the lock is released
    </pre>
    <pre>
    import threading
    
    lock = threading.Lock()
    
    lock.acquire()
    
    print( lock.locked() )                                // -> True
    lock.acquire()                                        # program will hang because the lock is closed (this is called deadlock)
    </pre>
    <p> - <mark>RLock</mark> </p>
    <p> - thread-1 acquires the lock and blocks thread-2 and thread-3 untill it releases the lock again </p>
    <pre>
    import threading 
    import time
    
    lock = threading.RLock()
    
    def th(name):
        print( f"{name} tread started")
        
        lock.acquire()
        time.sleep(0.1)       # simulating some work
        
        print( f"{name} tread end")
    
    th1 = threading.Thread(target=th, args=[1])
    th2 = threading.Thread(target=th, args=[2])
    th3 = threading.Thread(target=th, args=[3])
    
    th1.start()
    th2.start()
    th3.start()
    </pre>
    <pre class="cmd">
    1 tread started
    2 tread started
    3 tread started
    1 tread end
    </pre>
    <p> - within the same thread the reentral lock can be unlocked several times </p>
    <pre>
    import threading 
    import time
    
    lock = threading.RLock()
    
    def th(name):
        print( f"{name} tread started")
        
        for i in range(3):
            lock.acquire()        # acquired 3 times 
            time.sleep(0.1)
        
        time.sleep(1)
        for i in range(3):
            lock.release()        # released as many times as it was arquired to unlock the lock  
        
        print( f"{name} tread end")
    
    th1 = threading.Thread(target=th, args=[1])
    th2 = threading.Thread(target=th, args=[2])
    th3 = threading.Thread(target=th, args=[3])
    
    th1.start()
    th2.start()
    th3.start()
    </pre>
    <pre class="cmd">
    1 tread started
    2 tread started
    3 tread started
    1 tread end
    </pre>
</details>
<hr>
<!--------------------------------------------------------------------------------->
<h2 class="header"> Other tools to control race conditions </h2>
    <p> - there are other tools to control race conditions as well such as <mark class="mark">Condition Objects</mark> <mark class="mark">Semaphore</mark> <mark class="mark">Barrier</mark> <mark class="mark">Events</mark> <a href="https://docs.python.org/3/library/threading.html#semaphore-objects" target="_blank">[link]</a> </p>
    
    
    
    
    
    
<hr>
<!--------------------------------------------------------------------------------->
<h2 class="header"> Communication between threads </h2>
    <p> - because threads run in the same process data in the main process is available for all threads (no need to use some communication channes like in <mark class="mark">multiprocessing</mark>) </p>
    
    
    <br><br>
</body>
</html>
